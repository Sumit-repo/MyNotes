                            Core-Java
JAVA
   * Java is a high-level programming language
   * Which is developed by James Gosling in the year of 1995.
   * Now it is owned by Oracle Corporation.

It is used for:
   * Mobile application
   * Desktop application
   * Web application 
   * Web servers and application servers(server that host through internet via web or software)
   * Games
   * Database connection ETC;

Java Architecture:
   * In source code file name will save as .java
   * Compiler will compile the program from source code into a byte code
   * Byte code generated file name as .class & it will run at any operating system
   * JRE is known as Java Runtime Environment & it will convert the byte code into a binary code.

Java is made up of three basic code structure:
    A class, which codes the basic unit of your code and describes the data and logic of your program, a package, which is an intermediate logical code aggregation. This is a high-level physical code aggregation, and it allows you to override the lower-level code aggregation of the package and choose, explicitly, what parts of your code you want to expose for reuse and people to access and what parts you don't.

Java standards:
   * In public class file name should be save as class name.
   * In class name first letter should be Uppercase.
   * Java is a case sensitive language.
   * In java file if we have multiple words for class name then we need to follow Camel-Case.
   * Method name should starts with lower case.
   * If we have multiple words for method name then every word first should be in uppercase from the second word. Like- is-Prime, am-Strong:
   * In one java file we can create any number of default classed but we cannot create more than one public class in java file.
   * When we create two class file while executing we have to call it every class separately.
   * We can save java file in another file name but class file generate in class name.
   * We can’t create 2 public class file in java.
   * Java program can be compile without main method but java program can’t be executed without main method.

Platform independent
    It is a platform independent language it means the byte code which is generated by JDK compiler it will run at any operating system.

Method
   * Method is a set of statement which is use to perform some task.
   * To execute method statement method calling is compulsory.
   * Main method is called by JRE.

Java comments
	Comments are used to write description about java statements.
There are two comments type:
	Single line comment ----------------------------
	Multi line comment /*--------------------------*/

Double Quotes
    When you are working with text, it must be wrapped inside double quotations marks " ".

The Print & Println Method
   * print( ) method, which is similar to println ( ).
   * The only difference is that it does not insert a new line at the end of the output:
   * We can also use the println ( ) method to print numbers.
   * We don't put numbers inside double quotes:
   * We can do mathematical operation in println ( )method

Identifiers:
    The names which are given by programmer is known as identifiers.
    Ex- class name, method name, variable name etc.

Identifiers rules:
   * Identifiers shouldn’t starts with digits.
   * While declaring identifier we shouldn't use any special characters except $ and _
   * Keywords or Reserve words shouldn't be used for an identifier
Ex-if, else, for, switch

Variables:
   * Variable is a container which is used to store a single value
   * Variables are temporary memory location

    Datatype= identifiers; variable declaration;
    Identifier= Value; variable initialization;

Types of variables:
   There are three types of variables:
   * Local variables
   * Static variables
   * Non-static variables

Local variables
   * The variables which are created inside the method those variables are called as local variables.
   * For local variables memory was allocated in stack memory during program execution time.
   * For local variables memory was allocated each type method is called.
   * Local variable doesn’t have any default values.

Static variables
   * The variables which are created inside class and outside method with static keyword.
   * We can create static variable and local variables with same name.
   * If there is a local variable with same name as static variable then the static variable must be referred with class name.
   * For static variable initialisation isn’t compulsory.
   * If we use static variable without initialisation then JRE assigns the default value according to data type. 
   * Java allocates only one copy of memory for static variables.
   * Static variables are refer either by using class name or by using object reference.
   * To use/refer static members object isn’t required.
   * Memory was allocated for static variables during class loading tank in class static / static pool area.
   * For static variables memory was allocate for only one time.
   * We can initialize static variables by using static block.
   * Static variables also known as class variables.
   * Non-static variables
   * Memory was allocated for non-static variables during object loading time
   * For non-static variables memory was allocated each type instance is created.
   * Non static variables is also known as instance variables
   * Memory was allocated for non-static variables in heap area.

Non-static variables
   * Non static are declared within a class without using static keyword
   * At least one object is required to use Non-static members.
   * Java allocate memory for all Non-static variables each type an object is created using new keyword.
   * Non-static members are referred using object reference.

In Java, there are different types of variables, for example:
   * String - stores text, such as "Hello". String values are surrounded by double quotes
   * int - stores integers (whole numbers), without decimals, such as 123 or -123
   * float - stores floating point numbers, with decimals, such as 19.99 or -19.99
   * char - stores single characters, such as 'A' or 'B'. Char values are surrounded by single quotes
   * boolean - stores values with two states: true or false

Data types:
    Data-types are used to represent the type of value which we store in variable

There are two type of data types:
   * Primitive
   * Non-primitive

Primitive datatypes
   * byte- 1 byte           D.F=0
   * short - 2byte          D.F=0
   * int - 4 byte           D.F=0
   * long - 8 byte          D.F=0lf
   * float -4 byte          D.F=0.0f
   * double - 8 byte        D.F=0.0
   * char - 2 byte          D.F=EMPTY
   * boolean - 1 byte       D.F=FALSE

Non-primitive data types
   * Class names
   * Strings
   * Arrays and many more
   Class names are non-primitive data types in java

Arithmetic operators
   * +, -, *, /, %, 
   * + + Increase the value of a variable by 1
   * - - Decrease the value of a variable by 1

Relational (Comparison) operators
   * == Equal to
   * != Not Equal
   * >Greater than
   * < Less than
   * >= Greater than or Equal to
   * <= Less than or Equal to

Logical operators
   * && Logical and
   * || Logical or
   * ! Logical not

Bitwise operators

   * & - bitwise and
   * | - bitwise or
   * ^ - bitwise xor
   * ~ - bitwise not
   * >> - bitwise right shift
   * >>> - bitwise unsigned right shift
   * << - bitwise left shift

Assignment operators
   * =, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=
Ternary operators
   * ?   :
Unary operator
    expr  ++, expr--, ++expr, --expr, +expr, -expr, ~ !

List of Java Keywords:
A list of Java keywords or reserved words are given below:

|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    abstract   |: Java abstract keyword is used to declare an abstract class. An abstract class can provide the implementation of the interface. It can have abstract and non-abstract methods.                                                   
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    boolean    |: Java boolean keyword is used to declare a variable as a boolean type. It can hold True and False values only.                                                                        
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    break      |: Java break keyword is used to break the loop or switch statement. It breaks the current flow of the program at specified conditions.                                                 
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    byte       |: Java byte keyword is used to declare a variable that can hold 8-bit data values.                                                                                                     
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    case       |: Java case keyword is used with the switch statements to mark blocks of text.                                                                                                         
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    catch      |: Java catch keyword is used to catch the exceptions generated by try statements. It must be used after the try block only.                                                            
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    char       |: Java char keyword is used to declare a variable that can hold unsigned 16-bit Unicode characters                                                                                     
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    class      |: Java class keyword is used to declare a class.                                                                                                                                       
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    continue   |: Java continue keyword is used to continue the loop. It continues the current flow of the program and skips the remaining code at the specified condition.                            
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    default    |: Java default keyword is used to specify the default block of code in a switch statement.                                                                                             
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    do         |: Java do keyword is used in the control statement to declare a loop. It can iterate a part of the program several times.                                                              
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    double     |: Java double keyword is used to declare a variable that can hold 64-bit floating-point number.                                                                                        
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    else       |: Java else keyword is used to indicate the alternative branches in an if statement.                                                                                                   
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    enum       |: Java enum keyword is used to define a fixed set of constants. Enum constructors are always private or default.                                                                       
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    extends    |: Java extends keyword is used to indicate that a class is derived from another class or interface.                                                                                    
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    final      |: Java final keyword is used to indicate that a variable holds a constant value. It is used with a variable. It is used to restrict the user from updating the value of the variable.  
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    finally    |: Java finally keyword indicates a block of code in a try-catch structure. This block is always executed whether an exception is handled or not.                                       
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    float      |: Java float keyword is used to declare a variable that can hold a 32-bit floating-point number.                                                                                       
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    for        |: Java for keyword is used to start a for loop. It is used to execute a set of instructions/functions repeatedly when some condition becomes true. If the number of iteration is fixed it is recommended to use for loop.         |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    if         |: Java if keyword tests the condition. It executes the block if the condition is true.                                                                                                 
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    implements |: Java implements keyword is used to implement an interface.                                                                                                                           
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    import     |: Java import keyword makes classes and interfaces available and accessible to the current source code.                                                                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    instanceof |: Java instanceof keyword is used to test whether the object is an instance of the specified class or implements an interface.                                                         
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    int        |: Java int keyword is used to declare a variable that can hold a 32-bit signed integer.                                                                                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    interface  |: Java interface keyword is used to declare an interface. It can have only abstract methods.                                                                                           
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    long       |: Java long keyword is used to declare a variable that can hold a 64-bit integer.                                                                                                      
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    native     |: Java native keyword is used to specify that a method is implemented in native code using JNI (Java Native Interface).                                                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    new        |: Java new keyword is used to create new objects.                                                                                                                                      
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    null       |: Java null keyword is used to indicate that a reference does not refer to anything. It removes the garbage value.                                                                     
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    package    |: Java package keyword is used to declare a Java package that includes the classes.                                                                                                    
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    private    |: Java private keyword is an access modifier. It is used to indicate that a method or variable may be accessed only in the class in which it is declared.                              
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    protected  |: Java protected keyword is an access modifier. It can be accessible within the package and outside the package but through inheritance only. It can't be applied with the class.      
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    public     |: Java public keyword is an access modifier. It is used to indicate that an item is accessible anywhere. It has the widest scope among all other modifiers.                            
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    return     |: Java return keyword is used to return from a method when its execution is complete.                                                                                                  
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    short      |: Java short keyword is used to declare a variable that can hold a 16-bit integer.                                                                                                     
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    static     |: Java static keyword is used to indicate that a variable or method is a class method. The static keyword in Java is mainly used for memory management.                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    strictfp   |: Java strictfp is used to restrict the floating-point calculations to ensure portability.                                                                                             
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    super      |: Java super keyword is a reference variable that is used to refer to parent class objects. It can be used to call the immediate parent class constructor & method.                    
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    switch     |: The Java switch keyword contains a switch statement that executes code based on test value. The switch statement tests the equality of a variable against multiple values.           
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   synchronized|: Java synchronized keyword is used to specify the critical sections or methods in multithreaded code.                                                                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    this       |: Java this keyword can be used to refer the current object in a method or constructor.                                                                                                
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    throw      |: The Java throw keyword is used to explicitly throw an exception. The throw keyword is mainly used to throw custom exceptions. It is followed by an instance.                         
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    throws     |: The Java throws keyword is used to declare an exception. Checked exceptions can be propagated with throws.                                                                           
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    transient  |: Java transient keyword is used in serialization. If you define any data member as transient it will not be serialized.                                                                                         |                |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    try        |: Java try keyword is used to start a block of code that will be tested for exceptions. The try block must be followed by either catch or finally block.                               
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    void       |: Java void keyword is used to specify that a method does not have a return value.                                                                                                     
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    volatile   |: Java volatile keyword is used to indicate that a variable may change asynchronously.                                                                                                 
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    while      |: Java while keyword is used to start a while loop. This loop iterates a part of the program several times. If the number of iteration is not fixed it is recommended to use the while loop.                                      |
|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

Scanner:

   * Before using the Scanner class, you need to import it at the beginning of your Java file: import java.util.*;
   * To use the Scanner class, you need to create an instance of it and associate it with an input source.
   * You can use various methods provided by the Scanner class to read different types of input. Here are a few commonly used methods:
   * nextInt(): Reads an integer from the input.
   * nextLong(): Reads a long integer from the input.
   * nextDouble(): Reads a double precision floating-point number from the input.
   * next(): Reads a single word (sequence of non-whitespace characters) as a string.
   * nextLine(): Reads an entire line of text (including spaces) as a string.

SWITCH

   * Switch is a keyword.
   * Case is a keyword.
   * Default is a keyword.
   * Default block is not mandatory.
   * Switch block is use it to find the matching record.
   * In switch block if there is no matching record default block will execute.
   * To switch block we are going to pass variable, values, expression.
   * We can’t pass any conditions to the switch block.
   * Inside switch block we are going to declare case block.
   * We can’t pass any variable to case block.

Break

   * Break is a keyword in java.
   * Break is also known control transfer statement.
   * We are using break keyword inside switch block and inside looping statement.
   * When break keyword is executed control transfer out of the block

Nested if

    We can’t pass long, float, double, boolean values to the switch block.
Looping statements:
   * To repeat the set of statements in java we are using looping statements
   * Loop will be interact until given condition will became false.
   * In every loop we are going for (initialization, condition, and updation).
   * There are 4 types of loops in java:
   * for()-loop
   * while()-loop
   * do-while()-loop
   * for-while()-loop

METHOD:
    Syntax: Modifiers return-type name (arguments)

There are two types of modifiers:
   * Access modifiers
   * Non access modifiers

Access modifiers:
    Access modifiers in java are used to either increase the security or visibility of a members.

   Primary/Private
      private int privateVar;      // Accessible only within this class
   Protected
      protected int protectedVar;  // Accessible within this class and subclasses
   Public 
      public int publicVar;        // Accessible from anywhere
   Package/default
      Package packagename;         // Package-private, accessible within the same package

Private:
   * Private members are available only for the current class
   * Private is a keyword in java which increase the security of a member.
   * A member declared as private can be access within the class 
   * It can’t be access even in their subclasses
   * To access private members public method are defined

Default:
   * Default members are available for all classes of current package
   * Protected:
   * Protected members are available for all classes of current package and for only subclasses of another package
   * Protected keyword in java allows any class to access within the package 
   * To access protected in other package is a relationship is mandatory
   * Only the subclass object can access the protected members in other package

Public:
   * Public members can be access by any class 
   * Public keyword allows the member to be use or access within the entire project
   * If a member declared without any access modifier, by default it belongs to package
   * These members can be access within the package but another packages of the project.
   * The file name and class name which contains methods should be same and the class must be public.

Non access modifiers:
   * Static
   * Final
   * Abstract
   * Synchronized
   * Native

TYPE CASTING:
   * Converting one data type to another data type is known as type casting.

    Type casting classified into two types:
        * Primitive type casting
        * Non primitive type casting

    Primitive type casting
        * Converting one primitive data type to another primitive data type is known as primitive type casting
        * Primitive type casting is applicable only for primitive data types.

    There are 2 types of primitive type casting
        * Widening
        * Narrowing

    Widening 

        * Converting lower range datatype to higher range datatype is known as widening
        * In widening process there is no data loss.
        * Widening process also known as implicit/automatic type casting.
        * Compiler automatically its convert lower data type to higher data type.
        * We can achieve widening implicit also and explicit also by using type cast operator.

    Narrowing

       * Converting higher data type to lower data type is known as narrowing.
       * In narrowing process data loss is there.
       * Narrowing also known as explicit type casting
       * We can achieve by using type cast operator

    Non-primitive type casting

       * Up casting
       * Down casting
       * Specialization
       * Object level widening
       * Implicit/explicit
       * Object level narrowing
       * Explicit
       * Generalization

Method

    Method is a set of statement which is use it to performing a task.
    Methods are two types
       * Predefined method
       * User defined methods
    Methods are classified into two types based on arguments
       * Parameterise method
       * No arguments method
    To call parameterise method number of formal arguments and number of actual argument should be same.
    Based on behaviour methods are classified into two types
       * Static method
       * Non static method
    Static method
       * If the method having static keyword as a modifier is known as static method.
       * Static method are prefixed with static keyword.
       * We can call static method directly by using class name.
       * We can call static method without using class name in same class.
    Non static method
       * Non static doesn’t have static as a modifier.
       * Non static method also known as instance method.
       * We can’t declare method inside method.
       * We can call non static method by using instance.
    Method overloading
       * Creating more than one method with same name with different formal arguments is known as method overloading.
       * In method overloading signature should be same.

                    
OOPS (Object oriented programming system)
    By using java we are going to represent real world objects

What is object?
    Every real world entity which has state and behaviour is known as an object.
    Java isn’t 100% OOPL because of primitive data types but we can use wrapper classes to make it 100% OOPL.
    An object is an instance of a class. A class is a template or blueprint from which objects are created.

Object has three characteristics:-
    *State (variables)
        State represents the data of an object
    *Behaviour (method)
        Behaviour represents the behaviour of an object
    *Identity
        It is used to internally by the JVM to identify each object uniquely

The 4 main pillars of oops
   * Abstraction 
   * Encapsulation
   * Inheritance
   * polymorphism

Class loading

   * Copying the library form primary memory to secondary memory is known as class loading.
   * All static members get allocated
   * We can access static methods
   * Class names is used to access static methods

Object creations

   * All non-static members memory get allocated
   * We can access static members.
   * We can access non static members
   * Object reference is used to access non static members.
   * If you want to use object we must need to store in a reference variable. 
   * Object are store in heap in memory.
   * Class is loaded first then object is created
   * Static members gets memory allocated during class loading
   * Non static memory gets memory allocated during initialization
   * Inside non static methods both static and non-static members can be access
   * Inside static method static data members can be accessed directly but not non static data members
   * To access non static data members inside static method, create object of the class and access it.
   * Static variables created is one copy for the whole program
   * All the object of the class will be sharing the same copy
   * Non static variables has individual copies for all individual objects
   * Changes made to non-static variables of one object will not affect the non-static variables of another object

BLOCKS

    Blocks are also called as multi line initializer.

There are 2 types of blocks
   * Static blocks
   * Non – static blocks

       * Static blocks are executed when the class is loaded
       * Non static blocks are executed during initialisation 
       * Static blocks are executed only once
       * Non static blocks are executed for every object created.
       * If there are more than one static block then they are executed sequentially 
       * If there are more than one non static blocks they are executed sequentially.
       * Using static block initialize static data members
       * Non static blocks are used to initialize to use non static data members
       * Inside static blocks, non-static data member can directly initialize.
       * Inside non static blocks we can access both static and non-static data members.
       * Inside non static blocks we can initialize static data members.

THIS KEYWORD:
   * This keyword can be used to access static data members inside non static data members.
   * Call to this is used to call the constructor from another constructor
   * We can call at most only one constructor from another constructor.
   * Call to this ( ) super should be the first statement of the constructor
   * Calling the constructor from another constructor to pass values is known as constructor change.

Difference between this and call to thia:

This:
   * this keyword can be used to access both instance (non-static) and static members within a class.
   * It is commonly used to differentiate between instance variables and method parameters when they have the same name.
   * It cannot be used to change the data type of a variable or for type casting
   * It can be used in non-static (instance) methods, constructors, and blocks.
This ( ):
   * Call to this is used in constructors to call another constructor within the same class.
   * It is used to reuse code and initialize the object with different constructors.
   * Call to this () should be the first statement in a constructor.
   * It is only used to call the constructors not for calling the methods or blocks.

CONSTRUCTOR

   * Constructor is a set of statement that is executed when the object is created
   * It is a special method 
   * It can have access modifier.
   * If we don’t pass access modifier it has default access modifier.
   * Constructor are used to initialize the object during instantiation.
   * Constructor doesn’t have any return type not even void.
   * Constructor is defined using class name.

There are two ways to define a constructor.

   * Parameterise constructor.
   * Default constructor.
       * No argument constructor is known as default constructor.
       * Constructor without is known as parameterise constructor.
       * If the return type is provided to a constructor java will not through any error instead it interprets (JVM) as non-static method. 
       * This keyword can be used inside constructor. 
       * If a class don’t have any constructor define by the developer, then JVM internally creates as constructor known as default constructor. 
       * Constructor overloading
       * Having the same constructor name with different arguments is known as constructor overloading.
       * Constructor can be overloaded based on the length and type of the arguments.
       * Method overloading and constructor overloading archives compile time polymer. (polymorphism)

Break labels
    A :{
	    } return A;
All non-access modifier are known as keyword.

Final keyword:
   * Final is a keyword in java which is used to impose restriction on a variable, non-static methods and also classes.
   * Final methods can’t be over written.
   * Final classes can’t be inheritance or extended.
   * Final keyword for a variable
   * Final keyword converts a variable into a constant.
   * Final variable do not have default values.
   * One’s final variable is initialize, it can’t be reinitialize.
   * Final variable can be local, static, and non-static.
   * Final variable without initialization in known as blank final field.
   * If the blank final block is static, we can initialize using static block.
   * If the blank final block is non-static we can initialize using non static block.

Inheritance:

   * (Is a relationship)
   * Acquiring the properties and behaviour of parent class to child class is known as Inheritance.
   * It is unidirectional.
   * It is efficient to create the object of subclass
   * Static members and constructor do not participant in inheritance / because in sub class it has different name (name of sub class).
   * In a constructor one might call other constructors.
   * In the same class using call to this.
   * In extended class using call to super.
   * Sub class is a covariant of super class.
   * Super is contravariant of sub class.
   * (Parent-child, base- derived, super-subclass)
   * The dependency between two objects its similar like parent and child is known as Is-A relationship
   * Is-A relationship is also known as inheritance.
   * We can achieve inheritance by using extends keyword.
   * One class can extends only one class at a time.
   * In is a relationship child class required all the properties of parent.
   * And child can have its own properties also.

There are 4 types of inheritance:
   * Single level inheritance   (child-parent)
   * Multilevel inheritance (parent child-child )
   * Hierarchical inheritance (parent child-child- child )
   * Hybrid inheritance (2 parent- child- )
   * Multiline inheritance (child-Parent parent // it is not accepted by java)
 

Single level inheritance
   * One class is extending on another one class.

Multilevel inheritance
   * One class is acting as a child and parent also at a same time.
   * Inheritance more than one level is known as multilevel inheritance

Hierarchical inheritance
   * One parent class can have more than one child is known as hierarchical inheritance.
   * Through classes multiple inheritance is not supported in java.

Hybrid inheritance
   * It is a combination of two different inheritance.
   * Hybrid inheritance isn’t supported in java.

Multiline inheritance
   * One child class can have more than one parent is known as multiline inheritance.
If we are trying to achieve multiple inheritance or hybrid inheritance through classes we will get diamond problem

Q. Why multiple inheritance isn’t supported through classes in java?
	> If a class extends more than one super class, if all super classes provide same behaviour with different implementation then JVM doesn’t know which method implementation to call for the sub class creating an ambiguity error
	> This ambiguity error is known n as diamond problem.
   > Since there is no solution for this java doesn’t support multiple inheritance through classes in java

Factory method:

  * A method which returns the newly created object is known as factory method
  * If the factory method is defined within the class it should be static.

Super:

  * Super keyword is used to access the properties created with the same name as in sub class from the immediate super class.
  * Super is a keyword use it to refer parent class properties in child class
  * By using super keyword we can call super class variables and methods
  * If parent class and child class having same members with same name in this situations we can refer the parent class members by using super keyword.
  * Super we can’t use in static context.

Call to super:

  * Call to super is constructor call statement
  * By using call to super we can call parent class constructor.
  * Every constructor is having by defiantly call to super the first line of the constructor
  * Call to super should be first line of the constructor.

Differences between super and this

   Super
     * Call to super is use it to call the immediate parent class constructor
     * Default call to super statement it will call always no argument constructor of parent class
     * We can’t use call this and call to super in same constructor.
   
   This
     * Call to this is use it to call the another constructor in same class.
     * Call to super should be used only for constructors not for method.
     * Call to this is use it to first line of the constructor
     * this super
     * this ( ) super ( )

Object class:
   * Object class is a predefined non primitive type 
   * Object class is a super most class of the entire class hierarchy
   * It is available in java.lang package.
   * Every class created in java is a subclass of object class
   * For every subclass extend object is internally executed can also be explicit.
   * Object class has only one constructor which is default constructor.

Methods of Object class:
  * Public string toString( )
  * Public int hashcode( )
  * Public Boolean equals (object obj)
  * Public final void wait(long m)
  * Public final void wait (long m, int n)
  * Public final void notify( )
  * Public final void notyfyAll( )
  * Public final class getclass( )
  * Protected void finalize( )
  * Protected object clone( )

Annotation
  * Annotation - Annotation in java are used to provide some special instruction to JVM.
  * Annotation can be used for - classes, methods, data members, constructors, interfaces.
  * Annotation should start with '@' special character.
  * Annotation 1st letter will be capital (Capitalized) (for primitive).

@Override  
   @Override annotation is present in java.lang package.
   This annotation informs J.VM to check proper method overriding.
   This is not mandatory for overriding. It’s just a good practice.

Method overriding:
  * Method overriding - Same method with same signature (argument).
  * Changing the implementation of super class in sub class using the same method signature/declaration is known as method overriding inheritance is mandatory.
  * If the sub class is not interested with the implementation provided by super class, it will Change the implementation in the sub class using the same method signature known as method overriding.
  * Only is two class has same non static method and is-a relation then only it’s considered to be Method overriding.
  * If both has same static method and is-a-relation then it’s considered to be Method Hiding/Shadowing.

Rules of overriding:
  * Only non-static, non-private, non-final method can be overridden.
  * While overriding we can retain the access modifier or use wider access modifier/increase the visibility of access modifier
  * We can’t use weaker access modifier/can’t reduce the visibility of access modifier. (like public, protect we can’t use)
  * While overriding if parent class return type is primitive datatype then sub class return type must be same (even for void).
  * If parent class return type is non-primitive, then sub class return type can be same type or co-variant but not contravariant (other type).

Binding:
   The process of connecting the method call to its's method implementation / definition is known as binding

There are two types of binding
  * Early binding
  * Late binding

Early binding
  * JAVAC (early binding, static binding, compile time binding)
  * The process of connecting a method call to its method definition by compiler based on the type (argument type) is known as early binding.
  * All static data members are binded at compile time.
  * Private method, static method, final method, overloaded methods are binded are compile time.

Late binding
  * JVM (late binding, dynamic binding, runtime binding/dynamic method dispatched)
  * The process of connecting a method call to its method definition it’s by JVM based on the instance type or object is known as late binding.
  * All non-private, non-static, non-final, over ridden methods achieve late binding.

Method hiding
  * If the super class and sub class having static method with the same name and same signature is known as method hiding on method shadowing.
  * The subclass static method is hidden from JVM.

Abstract:
  * The process of hiding only the implementation from the user and providing only the behaviour (functionality) is known as abstraction.
  * Abstraction in one of the core features or pillar of oops.
  * Abstraction is also known as implementation hiding.
  * Abstract is keyword and it is a modifier.
  * Abstract keyword is used for methods and classes.
  * If any class is having any abstract method then it is mandatory to make the whole class as abstract class
  * Abstract keyword we can’t use for variables. 

Abstraction can be achieved in two ways:
  * Using abstract class
  * Using interface.
--------------------------------------------------------------------------------------------------------------------------------
 

Advantages:
  * User-friendly/developer friendly
  * It code reusability.
  * Achieves loose coupling.
  * Achieves abstraction.
  * Implementation hiding.

Abstract method:
  * The method pre-fixed with abstract keyword is known as abstract method.
  * Abstract method is also known as incomplete method.
  * Abstract method always ended with (semi-colon ;).
  * Abstract method doesn’t contain any method body it contain only method declaration.
  * Can’t instantiate.

Abstract class:
  * A class prefixed with abstract keyword the class in known as abstract class.
  * We can’t instantiate abstract class (we can’t create object).
  * Abstract class just like a normal class.
  * Abstract class is also known as incomplete class.
  * In case if a class having one abstract method then it is mandatory to make class as abstract.
  * Which method we can’t overwrite those we can’t make them abstract.
  * Abstract class can contain concert methods also. 

   abstract public void m2( ); 
   public abstract void m5( ); 
   public abstract static void m1( ); n
   public abstract final void m3( ); n
   private abstract void m4( ); n

Concert method
   A method with body or a method with complete implementation is known a concert method.

Concert class
  * A class isn’t having abstract methods the class is known as concert class.
  * Concert class contain methods with full implementation.
  * Can instantiate

Non-:
   We can make non-static, non-private, non-final methods as abstract method.

Q. Who will provide body for abstract methods?
  > Sub class (The class which is extends abstract class the class have to provide body for abstract methods).

Interface:
  * It is an interface (mediator) between service provider and user program.
  * Interface is used to achieve multiple inheritance.
  * An implementation class can provide implementation for more than one interface.
  * Implementation class must provide implementation for all the abstract method of an interface, otherwise the implementation class become abstract.
  * Interface is a non-primitive type.
  * Interface cannot be instantiate.
  * Interface reference can’t be used.
  * It is used to achieve abstraction.
  * It is used to achieve loose coupling.
  * Interface consists of static context and abstract methods.
  * In interface only public, static and final data members are allowed, by default the data members are public static final.
  * Till JDK 1.7 interface allows only public and abstract method.
  * By default interface methods are public and abstract.
  * Interface do not have constructor.
  * Interface keyword is used to define an interface.
  * From JDK 1.8 interface consists of concrete method known as default method and static method.
  * From JDK 1.9 interface consists of private method.
  * A class which overwrite the abstract method of an interface is known as implementation class implement keyword is used.
  * An interface more than one implementation class can implement the same interface.
  * Interface is a type which consists of only abstract methods.
  * In interface we declare only those methods/behaviour which is required for the user.
  * Service provider will provide implementation for the abstract method declare in the interface.
  * For users the details in the interface is enough to use the user code.
  * Service provider code and user code are detached directly but connected through interface.
  * To develop the user code it is not required to know the service provider code.
  * At runtime JVM executes the implementations based on the instance created.

Advantage of interface over abstract class:
  * A class can extend one abstract class.
  * A class can more than one interface
  * As class can provide implements for multiple types if it is interface parent type or super type.
  * If drivable, flyable, floatable, are interfaces a class can provide implementation for all the type.

What is the advantage class over interface?
   Abstract class is used to provide partial information about a particular type.

Default for interface:
  * In java 8 feature, interface allows a non-static concrete method known as default method.
  * In interface implementation for a method is provided by default method.
  * Default methods should be defined using default keyword.
  * Overriding a default methods in implementation classes isn’t mandatory.

Use of default methods in interface:-
  * Default methods in interface is used to add new behaviours to the existing interface without breaking the existing implementation classes.
  * From java 1.8 interface consist of another concrete method known as static methods.
  * Static methods of an interface is access using interface name.
  * From java 9 interface consists of private methods.

Up-casting:
  * Using up-casting reference we can access generic properties
  * Specific properties can’t be accessed.
  * Overridden method can be accessed using super keyword.
  * We can’t access specific duplicate variable, we can only access generic variables.

Down casting:-
   A a = new B ( ); //up-casting
   B b = (B) a; // down-casting

     * Converting super class reference to sub class reference is known as down-casting.
     * Down-casting also known as converting up casted reference to sub class.
     * To achieve down-casting up casting is mandatory
     * Without up casting we can’t achieve down casting.
     * Is a relationship is also mandatory.
     * By using down-casted reference we can access parent class properties and specific properties of sub class also.
     * Down-casting is achieves explicit casting.
     * In down casting we are use type cast operator.
     * Instance of keyword:
     * Instance of keyword in java is used to check whether the object belongs to its type or covariant type.
     * Syntax: - reference instance of type
         Is-a relationship is mandatory.
         It returns true if the object belongs to their types if not then it will return false.

Function interface:
There are two types of interface:
  * Pre-defined interface
  * User define interface

Predefined interface:-
   Comparable – public  int compute(Object)
   Comparator – public int comparator(object e, object e)
   Runnable – public void ran( )
     * An interface which consists of at most one abstract method is known as functional interface.
     * It is used to achieve one task or one function.
     * Default methods and static methods are allowed in function interface.
     * Functional interface can be predefined and user defined both.
     * @functionalInterface annotation is used to create functional interface but it is not mandatory.

Comparable interface:
   * The comparable interface defines a single abstarct method.
   * Any class implements this interface should provide implementation to the abstract method
   * The class must implement to specified on which attribute the objects of the class.
   * Any class which implement comparable interface is known as comparable types 
   * And the objects are known as comparable type objects 
   * The comparable type object are known as comparable in nature.
   * all wrapper classe immplements comparable interface, hence wrapper class object are mutually comparable.
   * String class implements comparable interface,hence string objects are mutually comparable.
	public int compareto(Object ele){}

Comparator interface:
   * The Comparator interface defines an abstract method 
   * A class which implements comparator interface is known as comparator type class.
   * The comparator interface is used to provide mutiple attirbute based sorting.
   * For each attribute we must define seperate implemntation class 
   * The comparator type interface is used to achieve non mutual comparation.
   * The comparator is defined in java.util package 

   public int compare(Object o1, Object o2){}

Marker interface:
  * It is an empty interface
  * It is also known as tag interface.
  * Marker interface are used to provide special information to JVM.
  * Marker can be user-defined and predefined.
  * Marker is called serializable (java.io)
  * Marker is called Random-Access (java.util)
  * Marker is called clonable ( ).
  * The interface which has empty interface it is also called tag interface in known as marker interface.

Polymorphism:
  * Polymorphism is a core features of oops (ploy->many, morphism-forms)
  * An entity showing the behaviour of another entity at different situations is known as polymorphism.
  * If we had a X1 object and asked it to behaviour, Java would automatically execute the behaviour code for the X1. If we had another objectX2 and we asked it to execute the behaviour, Java would automatically execute the behaviour code for a X2object. This ability of the Java runtime system to invoke the correct behaviour based on the type of object is called polymorphism.

Polymorphism is of two types:
  * Compile-time 
  * Run-time

Compile time polymorphism:
  * The call to overloaded methods is resolved at compile time by compiler (JAVAC) according to the / based on the argument/parameter is known as compile time polymorphism.
  * Method overloading archives compile time polymorphism.

Runtime polymorphism:
  * The call to the overridden methods is resolved at runtime by JVM based on the instance is known as runtime polymorphism
  * Method overriding achieve runtime polymorphism.
        
   Advantages of polymorphism:
      User-friendly/developer friendly
      It code reusability.
      Achieves loose coupling.
      Achieves abstraction.

Tight-coupling:-
   If service and end user code are connected in such a way that any changes made in the service provider code we directly affect the end user code.

Loose-coupling:
   If service and end user code are connected in such a way that any changes made in the service provider code will not affect the end user code.

Data encapsulations:
  * Data encapsulation is a core pillar of oops.
  * Wrapping the data member and the member functions into a single unit called class is known as data encapsulation.
  * Wrapping the data and code acting on the data into a single unit called is known as data encapsulation.
  * To create an efficient data encapsulated class we should declare the data members as private.
  * A public method is defined or created to fetch the value of a private data member known a getter method of accessor.
  * A public method is defined to set the value of a private data member 
  * To set the value of a private data member is known as setter method or mutator.

Applications of data encapsulations:
  * The complete control of the data member is with in the class.
  * Either we can provide read only access or write only access or both read write access for the private date member.
  * Any changes in the internal storage structure of the class will not affect the end user code.

Private constructor:
  * If a constructor is declared as private, the constructor is visible only within the class.
  * Objects for a private constructor can’t be created in other class.
  * Objects can be initialize only within the class.
  * To create an object we defined a helper method is known as factory method.
  * To declare a factory method we should.
  * Declare access modifier as public
  * Modifier as static.
  * Written must be class type.
  * And a user defined method name.

Single ton class:
  * A class which consists of at most one object is known as single ton class.
  * Single ton class is one of the design pattern in java.
  * To create a single ton class we can achieve early instantiation or lazy instantiation.
  * Declare a static variable of class type
  * Create a private constructor.
  * Define a factory method which return the object reference on the condition.

Has a relationship:
Association:
  * An entity communicating with other entity through objects is known as association.
  * Association is also known as has a relationship.

Some several types of association:
  * One - one
  * One - many
  * Many - one 
  * Many - many

Association are of two types:
  * Aggregation 
  * Composition

Aggregation:
  * Declaring a reference of one class inside of another class is known as aggregation. // downcasting
  * The existence of the container object isn’t completely dependent on the existence of the contained object.

Composition:
    * Composition is a type of aggregation.
    * The existence of the container is completely dependent of the contained object.
    * It is also a design principle used to build complex classes by combining or composing simpler classes and objects.
    * Composition is often used to achieve code reuse and maintainability while promoting a strong "has-a" relationship between classes.

To string method:
  * Without overriding to_string method if we try to print reference variable then it give address of an object.
  * If we want to print base of the properties of an object then it is mandatory to override to string method.
  * Without overriding to_string if we print reference then it will return address in the form of classname@hexadecimal.
  * The return type of to string method is string type.
  * To string method is implicit as well as explicit.

Equals method:
  * Without overriding equals method if we try call to methods it will compare based on the address of an object but if we want to compare based on the object or based on the properties of an object then we need to override equals method.
  * The return type of equal method is Boolean type.
  * If we try to uses == operator to compare objects then it will compare it will based of address of an object.

Wrapper-class:
  * int – Integer
  * float – Float
  * byte – Byte
  * short – Short
  * boolean – Boolean
  * long – Long
  * char – Character
  * double – Double

    * Wrapper classes in java are a set of classes provide by the java to represent primitive data types as objects.
    * Wrapper classes are used to convert these primitive data types into objects.
    * wrapper class Comparable in nautre
    * Wrapper classed provide methods and constructors for converting between primitive types and their corresponding wrapper objects.
    * Allowing to perform a various operations on them and making them compatible with java object oriented features. 
    * Wrapper classes are final classes available in java.lang.package.
    * We can’t create objects of primitive data types.
    * It is used convert primitive to non-primitive vies-versa.
    * These classes are predefined concrete classes.
    * For every primitive data types, are respective non-primitive class is created by JDK.
    * They also offer utility methods for performing operations, comparisons, and conversions on these values.
    * Additionally, wrapper classes are frequently used when working with collections, as many collection classes in java (Arraylist, Hashset).
    * Converting primitive type- non- primitive types is known boxing (java 1.1-1.4).
    * Boxing is done manually till JDK 1.4.
    * From JDK 1.5 boxing is automated known as auto-boxing.
    * Converting non-primitive to primitive is known as unboxing (JDK 1.4-1.8).
    * Unboxing is manual till JDK 1.4 from JDK 1.5 boxing is automated is known as auto-unboxing
       
****************************************************************************************************************************************************************
Array
  * Array is the group of same type elements
  * Array can store only homogeneous type data
  * Array is a non-primitive type
  * Array is fixed size.
  * We can access array elements by using index values.

For-each loop
  * For-each loop is used it to print array or collections elements.
  * For each loop JDK 1.5 version
  * By using for each we can print elements in unique directions
  * Syntax: for ( array-type= variable: array ref ){}

for-each loop internally uses this process:
while (i.hasNext()) {
            Object ele = i.next();
            System.out.println(ele);
        }

2D array
  * Syntax:  Datatype [ ] [ ] = new datatype [row] [col];
  * During creations of 2d array row size mandatory, column size is not mandatory.
  * In 2d array the data will store.

SCP:
   * SCP - string constant pool
   * SCP is a pool of heap memory
   * When you create string with "" memory is assigned in SCP.
   * SCP will not allow duplicate elements
   * When we create string object by new keyword it assigned in heap memory
   * Heap memory allows to create duplicate elements
   * In SCP 1 data can referred by multiple reference variables.
   * The primary purpose of the String Constant Pool is to optimize memory usage by reusing common string values.
     When our Java program creates a string literal (e.g., "Hello"), the JVM checks if the same string already exists
     in the pool. If it does, the existing reference is returned, and a new object is not created. This mechanism is called string interning.

Immutable nature:
   * String is immutable.
   * If we add any data to string we can’t change or modify the data.
   * If trying to modify given data new object is going to create.
   * In SCP one string data can referred by multiple reference variables
   * If changes made by any one user the other user shouldn’t affect
   
Char sequence:

String buffer:
   * String buffer and string builder is a mutable versions of a string class.
   * String buffer are synchronize methods.
   * String buffer is thread safe.
   * By using string buffer we can modify the content of the sequence.
   * It is part of the java standart library and present in lang package.

String builder:
   * It is a subclass of char sequence.
   * Its not synchronized
   * Which makes it more efficient in a single-threaded environment.
   * String builder methods are not thread safe.

Comparable
  * Comparable is a predefined personal interface 
  * It’s present in java. Lang package.
  * It is having one abstract is called compareTo method
  * By using comparable interface we can sort of objects.
  * Sort method internally uses compareTo() method.
  * In compareTo method we can compare two object if the current object is greater than passed object then we have to return value.
  * If current object is lesser than passed object we have to return negative value otherwise 0;
  * By using comparable we can achieve single sorting sequence (we can compare by using only one attribute).
  * In java string class is implementing comparable interface
  * To compare two string values we use compareTo() method of string class
  * String implements comparable interface
  * In string compareTo() method is overwritten.

Disadvantages of comparable:
  * By using comparable interface we can compare two objects by one attribute at a time.
  * By using comparable we can achieve default sorting order in object.

Comparator:
  * Comparator is a predefined functional interface.
  * It is present in java.util package.
  * Comparator is having method called compare() method.
  * By using comparator we can sort collection of object.
  * By using comparator we can achieve custom() sorting.

Comparable comparator difference:

|---------------------------------------------------------------------------------------------------------|
|           Comparable:                              |              Comparator:                           |
|---------------------------------------------------------------------------------------------------------|
|    Comparable follows single sorting sequence:     |      Comparable follows multiple sorting sequence. |
|---------------------------------------------------------------------------------------------------------|
|    One argument compare method.                    |      Two argument compare method.                  |
|---------------------------------------------------------------------------------------------------------|
|    Comparable affects the current class.           |      Comparator doesn’t affect the current class.  |
|---------------------------------------------------------------------------------------------------------|
|    For default sorting                             |      Custom sorting                                |
|---------------------------------------------------------------------------------------------------------|

Regular expression:
  * In java regular expression is used to client site validation
  * In java there is a pre-defined package regex present in java.util package
  * Java regex is used for pattern matching & client site validation.
  * Usage of regular expression validation and verification.

|------------------------------------------------------|
|                       Validation                     |
|------------------------|----|------------------------|
| Client side validation |    | server side validation |
|------------------------------------------------------|

In regular expression dot operator is going to match any character in given string

Charset exp =a[abcd]
  * It is group of character it is going with one character
  * In regular expression only to string method is support.

Replace all
Split

  * Curly braces is a quantifier used to indicate previous character count
  * By using back slash escaping the meaning of next character

Find method:
   Find method will match the expression with substring in given string.

Matches method:
   Matches method will match expression with entire string.

Exceptions handling & multithreading:

  * Unexpected event which arises at runtime, which affects normal execution flow is called as exception.
  * When unexpected event arises  JVM creates an object of type Exception and throw.
  * Thrown exception object should be handled otherwise execution will be terminated immediately. 
      Try {
         Start which might throw an exception (risky statements).
      } Catch (Object e) {
         Var used to catch the thrown exp obj.
         Statements:
         Starts which executes (recovery logic) only when there is an exp in try block
      }

Throw-able:
   Error
      * Stack overflow
      * Out of memory error
      * Virtual machine error
   Exception
      * File not found exception
      * SQL exception
      * Runtime exception
      * Arithmetic exception
      * Null pointer exception
      * Class cast exception

There are two types:
   Checked exceptions
      * Exceptions which are subclass to Exception class but not sub class to Runtime Exception class are known as checked Exception.
      * For checked Exceptions compile checks for an handler at compile time
      * If checked Exceptions isn’t handled using try catch then it must declare using throws keyword
   Unchecked exceptions
      * Exceptions which are sub class to Runtime-Exception class is known as unchecked Exceptions.
      * For unchecked exceptions compiler doesn’t check for handler at compile time.
      * Providing a try catch for unchecked isn’t mandatory

|----------------------------------------------------------------------|-----------------------------------------------------------|
|                               Throw                                  |                       throws:                             |
|----------------------------------------------------------------------|-----------------------------------------------------------|
|  Throw is used to declare checked exception if it not handled        | Throws Keyword is used to throw an exception explicitly   |
|----------------------------------------------------------------------|-----------------------------------------------------------|
|  Throw can be used to throw either checked or unchecked exceptions   | Throws keyword is used to declare only checked exceptions |
|----------------------------------------------------------------------|-----------------------------------------------------------|
|  Using throw keyword only one exception can be throw                 | Using throws multiple checked exceptions can be declared  |
|----------------------------------------------------------------------|-----------------------------------------------------------|
|  Throw key word is used with in a method body                        | Throws keyword is used on the method signature            |
|----------------------------------------------------------------------|-----------------------------------------------------------|

Finally:
  * finally is written along with try or try catch
  * finally statements executes weather exception is thrown or not, weather thrown exception is handled or not
  * generally a clean-up statements such as closing the database connections, closing the streams, releasing costly resources will be written inside the finally block
  * When doesn’t execute:
  * When object of type error is thrown 
  * When system. Exit is called

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--Multi-Threaidng-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Multi-threading:

Multi-tasking
   * Performing multiple task simultaneously known as multi-threading.

Multi-tasking are types:
   * Process based multitasking
   * Thread based multitasking

|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
|             Process based multi-tasking                                                   Thread based multi-tasking:                           |
|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
|    * Process based multitasking is heavy weight process.                          * Thread is light weight sub process.                         |
|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
|    * In process based multitasking every process required individual memory.      * By using thread we can achieve multitasking in programs.    |
|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
|    * Process based multitasking used in OS level.                                 * In thread based multitasking threads will share same memory |
|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
|                                                                                   * Thread based multitasking also known as multi-threading.    |
|-------------------------------------------------------------------------------|-----------------------------------------------------------------|
   
Thread:
   Thread is a class in java, to define a thread execution.
   It is an execution having is own cpu & memory and at least one task.

Thread class:
   Thread class defines the thread properites and behaviour.
   Thread class is defined in java.lang pacckage.
   It is a implementation class of Runnable interface.

Thread class defines 3 attributes:
Thread id
Thread name
Thread priority

Thread id:
   * It is a unique identification of the each thread created in the JVM.
   * The Thread id is intialize by JVM by default and uniquely.
   * We can't assign or change the value of id.

Thread name:
   * Each Thread created in the JVM should have a name.
   * We can provide our own name for the thread if not it will default name.

Thread priority:
   * It is one of the property in thread class, every thread is having priority, the priority level is 1 to 10.
   * The thread priority defines the prority of the thread based on the thread priority, the JVM allocates thread resourses and schedule the execution.
   * Max priority =10; min=1; default= 5;
   * We can change the thread priority before starting a thread

Thread scheduler:
   * It is used it to schedule the tread.
   * It is a part of JVM.
   * It schedule the thread based on thread priorities.
   * It is a one type of daemon thread.
   * We can prevent thread execution by using 
      * Sleep
      * Joint
      * Yield (some operating system not supported for yield method).

   Thread class has overloaded constructor.

Thread methods:

   public int getId(){}

   public String getName(){}

   public int getPriority(){}

   public void setName(String name){}

   public void setPriority(int priority){}

   public void start(){
      * On calling this method the thread is moved to the runnable state. It is ready to run but, but the scheduler hasn't selected it to be the running thread.
      * Once it enters the Runnable state, it is eligible to scheduled for execution by the thread scheduler.
      * From Runnable state to Running state the decision is selected by the factors susch as thread prority, thread scheduling policies
      * The transitionn from Runnable to Running states depends on the scheduler's decisions.
      * Its not directly controlled by the programmer.
      * The thread which is under execution is stopped and this method debricated.
   }
   
   public void run(){
      * The run method is used to define the task of the thread in thread class the run method as a empty body.
   }

   public void sleep(long time) throws InterruptedException{
      * The method causes the running thread to sleep for the specified time.
      * The Time value is always measured in micro-second.
   }

   public static void currentThread(){
      The method returns the reference to the currentThread running in the context.
   }

Difference between start and run:
   * Whenever start method called it register the execution, allocates cpu time and memory and then it internally calls runs method.
   * The start method allocate seperats stack and executes the rum method on the stack.
   * If the run method is called directly it will not get seperate cpu time amd stack memory instead it runs on current stack.
   * Hence multithreading cann't be achieved.

When we are executing java program JVM will create 3 threads:
   * Main thread
   * Thread scheduler
   * Garbage collector

There are two ways made thread:
   * Extends thread
   * Implements Runnable

   * Multi-threading using in animation and movies.
   * Threads are independent.
   * Each and every thread will maintain separate stack memory.
   * If any problem occurred in one thread it is not going to affect another thread execution.
   * We shouldn’t start method two time by using same thread instance.
   * Some operating system doesn’t supported for thread priorities.

   * The jvm internally creates a thread by name, the main thread is responsible to start the execution.
   * Thread main always makes a static call to the main method hence the main method should be static.
   * The main method should be public because it should be accessible by the main thread.
   * The thread main passes string array while calling the main method hence the main method parameter should be string array type
   * The thread main creates String array with the command line arguments and passes that array to the main method.
   * The jvm also start the internal threads by name thread scheduler and garbage collector thread.
   * The thread scheduler is responsible to schedule the thread for execution based on the thread priority.
   * The grabage collector is responsible to perform garbage collection processs.
   
Thread safe:
   A object which allows only one thread to use its data and method in a multi-threaded environment is known as thread safe.
   
The thread safe can be achieve in two ways
   By using synchronized keyword
   By developing immutable class.

Thread synchronization:
   * When a thread enters synchronised non-static method or sychronised block the thread accuries the object intrensic lock.
   * Until the thread releases the lock the object cann't be used by other threads.
   * The other thread which need the object will be blocked until the current running thread release the lock.
   * The thread which has the lock releases the lock when the task is completed
   * If a thread enters synchronised static method it accuries class intrensic lock.
   * The other can't access the class members until the lock is released.
   * The critical operations where only one thread should execute at a time, we make use of thread safe concept
   * The thread safe might result in delayed execution, if we don't write proper code it might end-up in thread deadlock.

Thread deadlock:
   * When two are more thread on a block stage and depending upon the blocked therad to complete the exectuion is know as therad dead lock.
   * In therad dead lock the object is locked and not other thread can consume it until the blocked thrad releases the lock.
   * To avoid thread dead lock we should use inter-thread communication method, which is achieved by [wait()/notify()/ notifyall()]
   * When a current thread executes wait method it releases the lock and enters wait state, the threas stays in the wait stage unitl it receive notification.
   * The wait method is a member of object class and it overloaded method.
         wait (){}
         waint(long n){}
         when a thread executes thread without specifying the time its waits in the wait statge unitl it receives notification.
         if Thread executes wait with time, the thread will wait in the wait stage 
         if notification receive within the time the thread resume back to the exectuion
         if the notification isn’t receive in time, the thread forceblly accuries the lock of the object.
   * When any thread executes notify() method it notifies the threads in the wait stage to resume the operation on the object
   * In this case FIFO order is follow
   * When a thread executes notifyall() method, it notifies all the threads in the wait stage.
   * The all thread run in race condition to accurire the object lock.
   * Both wait and notify method must be used only inside the synchronised method body.
   * If we use in a non-synchronised method body the JVM throws IllegalMonitorStateExectption

Threads are classified into two types:
   Daemon thread
   Non Daemon thread

Daemon threads:
   * Daemon also known as background working threads.
   * All daemon threads is having very low priority.
   * The priority will increase when non-daemon threads isn’t working.
   * Daemon threads started by JVM. Ex- GC thread, thread scheduler.
   * Daemon thread will execute until non-daemon threads will alive.
   * We can change daemon nature of a thread by using set daemon method.
   * We can change daemon nature before starting a thread.
   * We can’t change main thread daemon nature.
   * All user define threads we can call it is non-daemon threads including main thread.
   * When non-daemon threads will terminate immediately all daemon threads will terminate.

Non-Daemon Threads:

Synchronization:
   * Synchronization is a mechanism used to avoid multiple thread access for the same object.
   * Using synchronization we can avoid Thread race condition / Data Inconsistency problem.
   * We can achieve synchronization by using keyword called as synchronized.
   * Synchronized is a keyword as well as a modifier also.
   * By using synchronized keyword we can create thread safe method.
   * Synchronized keyword is only used for methods and blocks.

Thread safe methods:
   * Method accessed by only one Thread at a time.
   * Object level lock is created when we are making non static method as synchronized method.
   * Class level lock is create when we are making static method as synchronized method.

Dead-Lock:
   * Two Threads waiting for each other.
   * Dead-Lock also known as infinite waiting of a thread.
   * There is no resolution solution for Dead-Lock.
   * Because of synchronized keyword threads are going to Dead-Lock.
   * We can avoid Dead-Lock by using inter thread communication.

Inter-thread communication:
   * The communication between two threads.
   * By using wait ( ) and notify ( ) we can achieve inter thread communication.
   * By using Inter-thread communication we can avoid some deadlock situation.
   * Inter-thread communication is also known as consumer-producer relation.
   
   Methods used are:
         Wait ( )
         Notify ( )
         Notify-All ( )

|---------------------------------------------------------|-------------------------------------------------|
|             Wait( )                                     |              Sleep  ( )                         |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) is method of object class.                     | Sleep ( ) is method of thread class             |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) is a non-static method.                        | Sleep ( ) is a static method                    |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) can be used inside synchronized context only.  | Sleep ( ) can be used inside any method block   |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) will release the thread lock.                  | Sleep ( ) will not release any thread lock      |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) have 3 overloaded methods.                     | Sleep ( ) also have 3 overloaded method.        |
|---------------------------------------------------------|-------------------------------------------------|
| Wait ( ) is associated with notify ( ).                 | Sleep ( ) is not associated with any method.    |
|---------------------------------------------------------|-------------------------------------------------|

sleep:
   * public static member of thread class.
   * this method can be used in any method body
   * the sleep method passes the execution for the specified time
   * when a thread executes the sleep it carry the object lock
   * the method isn't used in interthread communication.

wait:
   * protected non-static method of object class
   * this method should be called only inside synchronised method body
   * The wait method causes the thread to enter the wait stage looking for the thread notification.
   * when the execute wait() method it release the object lock.
   * wait method is used to achieve interthrad communication and avoid therad dead lock

File handling:
   Operation to perform on file.
      * Read
      * Write
      * Create
      * Delete
      * Update

Create file:
   We can use file class in java to create a file object.
   CreateNewFile(): used to create file object, its present in java.io Package

Stream:
   Stream is a sequence of data (A group of data).
   This concept is used to perform input and output operation on a file.

There are tow types of streams:

   * INPUT STREAM
      * FileInputStream
      * ObjectInputStream

   * OUTPUT STREAM
      * FileOutputStream
      * ObjectOutputStream

Serializable:
   * The process of writing state of object to a file is called as serializable.
   * It is the  process of converting an object from java supported form to file supported form or network supported form.

Diagram:
|-------------------------------------------------------------------------------------|
|                                      |File|                                         |
|-------------------------------------------------------------------------------------|
| |Object|---|state of byteS|          | DB |             |Stack OF bytes|---|Object| |
|-------------------------------------------------------------------------------------|
|                                     |Memory|                                        |
|-------------------------------------------------------------------------------------|

By using fileoutpurstream and objectoutputstream classes we can achieve serialization.

FileOutputStream fs= new FileOutputStream("file location");
ObjectOutputStream os= new ObjectOutputStream(fs);
os.writeObject(ref);

className ref= (className)os.readObject();
System.out.println();

De-serialization:
   * The process of reading state object from a fole is called as deserialization.
   * It is the process of converting an object from file supported form or network supported form in to java supproted form.
   * By using fileinputstream and objectinputstream classes we can achieve De-Serializable.

>we can serialize only serializable Object

To achieve serialization
   * Class must implements serializable interface.

Serializable interface:
   * serializable interface present in java.io package it doesn't contain any methods, it is known as marker interface.
   * if we seiralize non-seriablizable object then we will get java.io.notserializableException.

transient keyword:
   * transient means not to serialize
   * it is a modifier which is appliable only for variable
   * in serialization if we don't want to save the value of variable for security then we should use trasient keyword
   * if variable is transient the JVM ignores the original values of tranisent variable and save the default value to the file.

static tranisent:
   * Static in not a part of object and the won't particippate in seriablizable.
   * we can use variable as static transient but there is no use of it.

final transient:
   * final variables will be participated in serialization directly by the value.
   * we can use varable as final transient by there is not use of it.

Character Stream - A group of Character oriented type data.
   E.g. Reader and Writer classes.

Byte Stream - A group of Byte oriented type data. 
   E.g. Input Stream and Output Stream classes.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--Collection-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Data structure:

HashBased Collection :
     - HashSet
     - LinkedHashSet
     - Hashmap
     - LinkedHashmap


-----------------------------------------------------------------------------------------------------------------
List interface: 
   List specification: 
      It follows insertion order.
      It allows operation of Duplicates data.
      It allows operation of null as a value.
         List L = new Array-List ( );
         List L = new Stack ( );
         List L = new Vector ( );
         List L = new Linked-List ( );

Differences between List and Set.
   List follows insertion order but set does not follow insertion order.
   List allows operation on duplicate data but we can have duplicate data in set.
   We can have multiple null in list but in set we can have only one null.


Vector:
Vector is a predefined sub-class of List interface.

It was introduced in JDK 1.1.
Present in java.util package.
Vector having 4 constructors
initial capacity 10
Initial capacity = current_capacity * 2.
Vector impliments Clonable, Serializable, Random-Access.



Stack:
Stack is a predefined sub-class of List interface.
It is present in java. lang package.
Stack follow First-in-last-out (FILO).

Queue:
It is a sub interface of Collection interface.
    * Present in java.util package.
    * introduced in JDK 1.2
    * Queue have sub-interface 
        - Deque
    * Implementation class of Queue
        - Array-Queue
        - Priority-Queue
        - Linked-List
    * Queue follows FIFO (First-in-first-out)

Differences between Queue and Deque.
Queue interface is provides methods for single ended queue.(We can add elements from only one end)
Deque interface is provides methods for double ended queue.(We can add element from either end)

Priority-Queue:
It is one type of single ended queue.
It will add elements to queue based on priority.
It will not follow order FIFO order9
Priority depends on ascending order.

Note: 
Duplicates are allowed in queue.
We can’t insert null.
Internally Priority-Queue used CompareTo ( ).
-------------------------------------------------------------------------------------------------------------------------
Set:
It is a predefined sub-interface of Collection interface.
It was introduced in JDK 1.2.
It is present in java. util package.

Specification of Set
Not follow insertion order.
Does not allows duplicate.
We can have only one null.

Tree-Set:
It is a predefined sub-class of Sorted-Set interface.
It was introduced in JDK 1.2.
Present in java.util package.
Tree-Set can store only same type of data.
Underlined DS of Tree-Set is Binary Search Tree.
In Tree-Set element is added in ascending order. (a-zA-Z)(0-9)
Tree-Set Internally used Comarable and Comparator.
We can’t insert null to Tree-Set.

HashSet:
HashSet is predefined sub class of set interface introduce in JDK 1.2 present in java. util package
Underline data structure is hash table
HashTable is using by hashing technique
Hash-set
Hash-Table (D S)
Hashing (process nm)
Hash-code (mtd)
Hash-set having four constructors
Hash-set implements serizable and clonable interfaces.
Insertion and deletion operation performed by hash-code
Hash-Set follows all 3 Specification of set.
Elements are arranged in random order.
All three specification 
The elements arranged in random order
Linked hash set:
It is a predefined sub class of sub interface present in java . util package introduce in jdk 1.4
Linked hash set working same as hash set but insertion order is preserved.
Iterator:
It is a predefined interface present in java. util pack introduce in JDK 1.2
By using iterator we can iterate any type of collection like list set and queue.
It is one type cursor
It is also known universal cursor
By using iterator we can iterate the collection in unidirectional 
Methods of iterator:
Boolean Hastnext ( )
Object next ( )
Void remove( ) ;
List iterator
It is predefined of sub interface of iterator interface present in java.util package 
By using list iterator we can iterator list type collection only
By using list iterator we can iterator unidirectional and bidirectional also.
Methods of list iterator:
Hasnext
Next
Hasprevious
Previous
Remove
Nextindex
Previous index
Map frameword		
<<Map>>
    - <<Sorted-Map>>
        - Tree-Map
    - Hash-map
        - Linked-Hash-map
    - Hash-Table
Map:
It is a collection of key value predefined interface pair present in java.util package
It is not a subtype of collection & index based
Map contains unique keys, we can’t have duplicate keys in Map.
Insertion, deletion, operation based on key values.
In map key value can’t null but value can be null.
Key should not be duplicate but value can be duplicate.
By using iterator we can’t iterate map.
Key can’t be a null.
Hash-map:
It is a predefined sub-class of Map interface.
It was introduced in JDK 1.2.
Present in java. util package.
It underlined DS is Hash-Table.
It doesn’t follow insertion order.
Duplicate key are not allowed.
Linked hash map:
It is a predefined subclass of map interface
It was introduce in JDK 1.2
Present in java. util package
It is same as hash map but it preserves insertion order
Hash-code:
It is an algorithm used to store the elements based on hash code
Every object is having unique hash code.
We will get hash code calling by using hash code method.
Hash code is object class method.
In some predefined classes hash code and equals method are overridden (ex: string)
In some user defined classes explicitly we have override hash code method.
Tree-Map:
It is a predefined sub-class of Sorted-Map.
Tree-Map Mainly used for sort element based on key values.
It internally uses Comparable and Comparator interfaces to sort element.
We can’t insert one null also.
We can store only homogeneous type data 

            HashMap                                 	HashTable
   * It was introduced in JDK 1.2 util.       *	It was introduced in JDK 1.0 util(legacy class).
   * Multi-threaded.                          * Single threaded.
   * Not synchronised                         * Synchronised.
   * faster                                   *	slower
   * Hashing technique                        *	Hashing technique
   * We can have one null                     *	No null allowed
   * Initial Capacity is 16                   *	Initial Capacity is 11
   * Load Factor is 75%-----------------------------------------------------------------------

Hash code method is developed by following below conditions:
If two objects is equal definitely hash code should be same
It any two objects having equals hash code the two objects may same may not be same.
Hashing
Hashing is an algorithm used to store elements based on hash code.
Every object has unique hash-code.
We will get hash-code by using hash-code ( ).
In some pre-defined class hash-code and equals method is overridden. eg. String class
In some user defined class we have to override hash-code method.
Hash-code ( ) is developed following below conditions.
If two objects are equal definitely hash-code should be same.
If any two objects have equal hash-code they may be same object or may not be.
Hash-table:
Data is stored in a key-value pair
Key is unique identifier or any value
Value is the actual data
Value is wrapping to key
Without key value can’t be accessed.
Entry:
An operation of (adding) key-value pair in hash-table.
